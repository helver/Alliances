/* The purpose of this utility is to generate "average" network traffic
   with the intent of monitoring a network traffic stream generated by
   another application.

   The idea is that the user will preconfigure the number, types, and
   starting times for multiple network streams prior to the beginning
   of the test, and this configuration will be used to generate a
   repeatable sequence of network traffic.

   In addition to this application, there will be an external graphic
   front end which would be used to configure the desired traffic
   patterns.

   Tcplib will be used to generate "average" traffic patterns, with one
   exception - tcplib has not been calibrated for WWW traffic.  It is my
   understanding that data for "average" WWW traffic has been specified, 
   and when I can find it, that information will be included in this
   package. 
*/
#define _REENTRANT

#include <thread.h>
#include <sched.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <stdarg.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <signal.h>
#include "trafgen.h"
#include "tcplib/brkdn_dist.h"
#include "tcplib/tcpapps.h"
#include "tcplib/tcplib.h"
#include "tcplib/tcplibgen.h"
#include "tcplib/tcplibutils.h"
#include "libnet/libnet.h"
#include <errno.h>


/* -----------------------------------------------------------

              Global Information and Settings

----------------------------------------------------------- */

int debug = 2;                       /* Debugging Level */
char * default_host = DEFAULT_HOST;  /* Default remote host */
int default_mtu = DEFAULT_MTU;       /* Default maximum transmission unit */
float default_factor = 1.0;          /* Default speed factor */
int seed_val;                        /* Random Number seed value */
long delay = -1;                     /* Initial Delay value */
int running_originals = 0;           /* Number of pre-scheduled events running */

int default_port[TYPE_TCPLIB] =      /* Ports for various services */
                { 21, 20, 119, 25, 23, 9, 80 }; 
int default_offset = DEFAULT_PORT;   /* Default discard ports offset */

struct traf_gen *schedule = NULL;    /* Schedule of events */

extern FILE* yyin;                   /* File pointer for yacc */

pthread_t desc_thrd;                 /* Thread descriptor */
pthread_attr_t attr;                 /* Thread attributes */

char huge_buffer[20000000];          /* Buffer of garbage data */
struct timeval stop;                 /* Time to stop the run */

extern void usleep(int);
extern int yyparse(void);
int my_sleep(struct timespec *sleep, struct timespec *blah);





int main(
    int argc,     /* Number of commandline arguments */
    char *argv[]  /* Commandline arguments */
    )
{
    char *conf_file = NULL;     /* Name of configuration file */
    int i;                      /* Looping variable */
    struct timeval now;
    struct traf_gen *this;

    SetMaxFiles(1024);          /* Sets number of file descriptors */
                                /* to 1024 */

    Signal(SIGALRM);

    gettimeofday(&now, (struct timezone *)NULL);
    stop = now;

    seed_val = now.tv_usec;

    /* Setting up thread specific information */
    memset(&attr, sizeof(pthread_attr_t), 0);

    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_attr_setstacksize(&attr, (size_t)100000);

    /* If there are no commandline arguments, then no configuration file has
     * been specified, if no configuration file has been specified then we
     * can't do anything, so let's just quit now and save ourselves some grief. */
    if(argc <= 1) {
	fprintf(stderr, "Error in trafgen execution - no configuration file specified.\n");
	fprintf(stderr, "Use: trafgen -? for more information on command line arguments.\n");
	exit(1);
    }

    /* We have one or more commandline arguments, so let's see what they are. */
    for(i = 1; i < argc; i++) {

	/* If the first char of the commandline argument isn't a '-', someone
	 * messed up.  And we get to tool on em for it. */
	if(argv[i][0] != '-') {
	    fprintf(stderr, "Error in trafgen execution - invalid command line argument - %s\n", argv[i]);
	    fprintf(stderr, "Use: trafgen -? for more information on command line arguments.\n");
	    exit(1);

	} else {

	    /* Here's where we find out what they want */
	    switch (argv[i][1]) {
	      case 'c':
		/* We'll use -c to specify a configuration file */
		conf_file = (char *)strdup(argv[++i]);
		break;
		
	      case 'p':
		/* We'll use -p to specify a default port offset */
		default_offset = atoi(argv[++i]);
		if(default_offset < 1024) {
		    printf("Invalid port offset - %d.  Exiting\n", default_offset);
		    exit(1);
		}
		break;

	      case 'h':
		/* We'll use -h to specify a default host */
		default_host = (char *)strdup(argv[++i]);
		break;

	      case 't':
		/* We'll use -t to specify a time to quit */
		delay = (long)atoi(argv[++i]);
		stop.tv_sec += delay;
		break;

	      case 'm':
		/* We'll use -m to specify a default mtu */
		default_mtu = atoi(argv[++i]);
		break;

	      case 'f':
		/* We'll use -f to specify a tuning factor */
		sscanf(argv[++i], "%f", &default_factor);
		break;

	      case 'd':
		/* We'll use -d to specify a debugging level */
		debug = atoi(argv[++i]);
		break;

	      case 'r':
		/* We'll use -r to specify a random seed value */
		seed_val = atoi(argv[++i]);
		break;

	      case '?':
		printf("Usage:  trafgen -c <config file> [-d debug_level] [-h host] [-p port_offset] [-t] [-f factor] [-r seed]\n");
		break;

	      default:
		/* If we didn't get a match above this, we did something wrong */
		fprintf(stderr, "Error in trafgen execution - invalid command line argument - %s\n", argv[i]);
		fprintf(stderr, "Use: trafgen -? for more information on command line arguments.\n");
		exit(1);
		break;
	    }
	}
    }

    if(!conf_file){
	fprintf(stderr, "Error in trafgen execution - no configuration file specified.\n");
	exit(1);
    }
    
    /* Ok, we're ready to go.  So let's go parse our configuration file */
    parse_configuration(conf_file);

    /* Seed the random number generator as prescribed by tcplib */
    srand48(seed_val);

    /* At this point we have our list of streams needed in the linked list headed
     * by schedule.  The streams are sorted by delay time - meaning that the one
     * that needs to go first is at the head of the list.  So now we go and do 
     * something based on that list. */
    for(this = schedule; this; this = this->next) {

	/* Creating a thread for each of the predefined events. */
	if(debug >= 6)
	    printf("spawning threads\n");

	if(pthread_create(&(this->desc_thrd), &attr, generate_traffic, this)) {
	    perror("Pthread_create");
	    exit(1);
	}

	if(debug >= 6)
	    printf("Back from the thread\n");

	running_originals++;
    }

    /* Now, the main thread just waits until all the predefined events
     * are done, or until the timer runs out. */
    while(   (running_originals > 0)
	  && (   (delay < 0)
	      || (now.tv_sec < stop.tv_sec))) {
	sched_yield();
	gettimeofday(&now, (struct timeval *)NULL);
    }

    return 0;
}



/* **************************************************************************
 * 
 * Function Name: new_traffic_item
 * 
 * Returns: A traffic structure with necessary info in place.
 *
 * Purpose:  new_traffic_item creates a new item to be added into the 
 *           schedule.  If the tcplib statement in the configuration file
 *           has a host and port specified, then the new item will use 
 *           those values, otherwise it gets default values.
 *
 * Called by: generate_traffic() in trafgen.c
 * 
 * ***************************************************************************/
struct traf_gen * new_traffic_item(
    struct traf_gen *loop /* tcplib item that generated this item */
    )
{
    struct traf_gen *new; /* pointer to the new traffic item */
    char *new_type;       /* String returned by next_app which 
                           * tells us what type */
    static int id = 0;    /* Traffic ID number */

    new = (struct traf_gen *)malloc(sizeof(struct traf_gen));
    clear_traf(new);
    
    /* If the master item has an address specified, use it, otherwise
     * just use the default host value */
    if(loop->address)
	new->address = (char *)strdup(loop->address);
    else
	new->address = (char *)strdup(DEFAULT_HOST);
    
    new->delay = -1;
    new->id = ++id;
    
    /* This is the call to tcplib which will determine what kind of traffic
     * this new item will be.  The return value is a string which we stuff
     * into new_type, and then we set up the item based on that string. */
    new_type = next_app(brkdn_dist());

    if(debug >= 3)
	printf("%s\n", new_type);

    /* Keeping track of the start time of the new item */
    gettimeofday(&(new->start), (struct timezone *)0);
    
    /* Easiest way to figure out what's what is to compare the first char
     * of the string.  Fortunately, we only get four values, and they all
     * start with a different letter, so it's mostly cake. */
    switch(new_type[0]) {
      case 't':
	/* new telnet stream */
	new->type = TYPE_TL_TELNET;
	new->active_timer = telnet_duration();
	if(debug >= 1)
	    printf("New Telnet connection.\n");
	break;
	
      case 'f':
	/* new ftp stream */
	new->type = TYPE_TL_FTP;
	if(debug >= 1)
	    printf("New FTP session.\n");
	break;
	
      case 's':
	/* new smtp stream */
	new->type = TYPE_TL_SMTP;
	if(debug >= 1)
	    printf("New SMTP connection.\n");
	break;
	
      case 'n':
	/* new nntp stream */
	new->type = TYPE_TL_NNTP;
	if(debug >= 1)
	    printf("New NNTP connection.\n");
	break;

      case 'c':
      case 'p':
	/* These two correspond to phone and converstaion intervals.
	 * They will probably never occur, but it's better to plan that
	 * they will and take appropriate measures than to believe that
	 * they won't and be taken by surprise. */
      case 'h':
	/* New http stream */
	new->type = TYPE_TL_HTTP;
	if(debug >= 1)
	    printf("New HTTP connection.\n");
	break;
	
      default:
	printf("Uncharacterizeable traffic type returned by next_app.\n");
	break;
	
    }

    /* Set the ports based on the type.  Since this function is only
     * called for TCPLib generated connections, we should be OK doing
     * it this way. */
    new->port = default_port[new->type - TYPE_TCPLIB -1] + default_offset;

    if(debug >= 6)
	printf("new->port - %d  new->type - %d\n", new->port, new->type);

    return new;
}


/* **************************************************************************
 * 
 * Function Name: generate_traffic
 * 
 * Returns: Nothing
 *
 * Purpose: generate_traffic is where most of our work gets done.  
 *          This is function contains the main timing loop, makes 
 *          calls to send data, decides when to remove items from 
 *          the schedule, and decides when to generate new items.
 *
 * Called by: pthread_create() in generate_traffic() in trafgen.c
 *            pthread_create() in main() in trafgen.c
 *
 * ***************************************************************************/
void * generate_traffic(
    void *param     /* Void pointer as required by pthread_create() */
    )
{
    struct timeval now,         /* Used to store the time of the current loop     */
	           start,       /* Used to store the time the program started     */
	           timepassed;  /* Used to keep track of how long the program has been running */

    struct traf_gen *new,       /* Used in the addition of new items to the schedule list */
	            *sched;     /* Data sent in in from pthread_create() */

    int errme;                  /* pthread_create() return value */
    struct timespec sleepy,     /* Sleep timers */
	            wakey;

    sched = (struct traf_gen *)param;

    if(debug >= 6)
	printf("In generate_traffic\n");

    /* Set the start time */
    gettimeofday(&start, (struct timezone *)NULL);

    /* Like all good graduate students - Sleep if you don't have to be awake */
    /* This usually comes into play for predefined events.  Such as an FTP 
     * session scheduled to start 10 seconds after TrafGen starts. */
    if(sched->delay > 0) {
	if(debug >= 6)
	    printf("Sleeping for %d seconds\n", sched->delay);

	sleepy.tv_sec = (time_t)(sched->delay);
	sleepy.tv_nsec = 0;

	if((my_sleep(&sleepy, &wakey))) {
	    printf("my_sleep didn't return 0 - %ld.%09ld\n", wakey.tv_sec, wakey.tv_nsec);
	}

	if(debug >= 6)
	    printf("Back from my %d second sleep.\n", sched->delay);

	sched->delay = 0;
    }

    /* The main loop.  We loop around until sched is NULL.  Sched goes
     * to NULL when the operation associated with sched is completed.  For
     * FTP, NNTP, HTTP, SMTP that is when we've transferred what we need
     * to transfer.  For TELNET and TCPLib events, it's when the timer
     * has expired. */
    while(sched) {

	/* Set the time for this loop */
	gettimeofday(&now, NULL);

	/* If we've exceeded our delay, then exit */
	if((delay > 0) && (now.tv_sec >= stop.tv_sec))
	    pthread_exit(NULL);

	/* Determine how long the program's been running */
	timepassed.tv_sec = now.tv_sec - start.tv_sec;
	timepassed.tv_usec = now.tv_usec - start.tv_usec;

	/* Yield the CPU to any waiting threads */
	if(sched->type != TYPE_TCPLIB && sched->descriptor > 1000) {
	    printf("File descriptor max exceeded.\n");
	    pthread_exit(NULL);
	}

	/* Give up the CPU to any other threads waiting to be run */
	sched_yield(); 
	
	/* Run characterize_traffic on the item.  If the item is new, this
	 * will flesh it out.  If it's not a new item, it'll send data */
	characterize_traffic(sched);

	/* Debugging information */
	if(debug >= 6)
	    printf("Timer - %d, Time difference - %ld\n", 
		   sched->active_timer, 1000*(now.tv_sec - sched->start.tv_sec));

	/* This part checks to see if a stream has completed.  For the FTP, NNTP, HTTP,
	   and SMTP, characterize_traffic sets the active member to -1 when the 
	   stream has completed.  For the telnet streams, the duration is checked
	   against how long the telnet stream has been active. */
	if(   sched->type != TYPE_TCPLIB
	   && (   (sched->active == -1)
	       || (   (sched->active_timer != -1) 
	           && (sched->active_timer < ((now.tv_sec - sched->start.tv_sec) * 1000))))) {

	    /* Debugging */
	    if(debug >= 2)
		if(sched->type == TYPE_FTP || sched->type == TYPE_TL_FTP)
		    printf("Removing an FTP item from the schedule.\n");

	    /* Remove the item from the schedule list. */
	    if(sched->type != TYPE_TCPLIB) {
		if(debug >= 2)
		    printf("Closing descriptor %d (%d)\n", sched->descriptor, sched->type);
		close(sched->descriptor);

		/* If the ftp_data_descriptor exists, then we must have opened
		 * an ftp data connection, so we kill the connection */
		if(sched->ftp_data_descriptor)
		    close(sched->ftp_data_descriptor);

	    }

	    /* If the type is less than TYPE_TCPLIB, then we know that it was an 
	     * original predefined event.  This being true, we decriment the number
	     * of predefined events currently running.  This helps us know when to
	     * quit the program. */
	    if(sched->type <= TYPE_TCPLIB)
		running_originals--;

	    free_traffic(sched);
	    
	    pthread_exit(NULL);
	    return NULL;
	}
    
	/* Only make a new stream for active tcplib items */
	if(   (sched->type == TYPE_TCPLIB)){

	    if(debug >= 5)
		printf("Generating new traffic items.\n");

	    /* Calls new_traffic_item to automatically generate and characterize
	       the new item */
	    new = (struct traf_gen *)new_traffic_item(sched);

	    /* spawn off new thread */
	    if((errme = pthread_create(&(new->desc_thrd), &attr, generate_traffic, new))) {
		perror("Pthread_Create");
		switch (errme) {
		  case EAGAIN:
		    printf("EAGAIN\n");
		    break;

		  case EINVAL:
		    printf("EINVAL\n");
		    break;

		  case ENOMEM:
		    printf("ENOMEM\n");
		    break;

		}

		exit(1);
	    }

	    /* When should we start another stream? */
	    sched->slave_delay = (int)(default_factor * conv_conv_time() * 1000);

	    if(debug >= 1)
		printf("Sleeping for %d microseconds.\n", sched->slave_delay);

	    if(sched->slave_delay > 5000000)
		if(debug >= 2)
		    printf("Long sleep\n");

	    /* Setting up the conversation inter-arrival time sleep */
	    sleepy.tv_sec = (time_t)(sched->slave_delay / 1000000);
	    sleepy.tv_nsec = (sched->slave_delay % 1000000)*1000;

	    /* Sleeping for the proper amount of time */
	    if((my_sleep(&sleepy, &wakey))) {
		printf("my_sleep didn't return 0 - %ld.%09ld\n", wakey.tv_sec, wakey.tv_nsec);
	    }

	    if(debug >= 2)
		printf("tcplib thread waking up\n");
	}
    }

    return NULL;
}



/* **************************************************************************
 * 
 * Function Name: setup_ftp_data_connection
 * 
 * Returns: Nothing
 *
 * Purpose: To set the variables needed for an FTP data connection.  To
 *          open a connection to the discard server to be used for an
 *          FTP data connection.
 *
 * Called by: characterize_traffic() in trafgen.c
 * 
 * ***************************************************************************/
void setup_ftp_data_connection(
    struct traf_gen *this    /* The current traffic item */
    )
{
    char buf[30];   /* Character buffer */

    /* Make the connection if you can */
    sprintf(buf, "%d", (this->port - 1));

    if(debug >= 5)
	fprintf(stderr, "Trying to make ftp connection to %s on port %s.\n",
		this->address, buf);

    if((this->ftp_data_descriptor = connectTCP(this->address, buf)) < 0) {
	fprintf(stderr, "Can't make ftp connection to %s on port %s.\n",
		this->address, buf);
	pthread_exit(NULL);
    }
    
    if(debug >= 2)
	printf("file descriptor - %d (7)\n", this->ftp_data_descriptor);

    return;
}
    

/* **************************************************************************
 * 
 * Function Name: characterize_ftp
 * 
 * Returns: Nothing
 *
 * Purpose: To take an FTP traffic item and fill out the variables needed
 *          to properly specify the event.  The FTP control connection is
 *          opened, transfer size is generated, and control size is 
 *          determined.
 *
 * Called by: 
 * 
 * 
 * ***************************************************************************/
void characterize_ftp(
    struct traf_gen *this  /* Traffic item to be configured. */
    ) 
{
    char buf[30];   /* Character buffer */

    /* Set the stream as active */
    this->active = 1;

    /* Set the various attributes according to tcplib */
    if(this->traffic_size == -1) {
	this->traffic_size = ftp_itemsize();

	/* In the final model, this should be ftp_nitems() instead of 1 */
	this->items = 1 /*ftp_nitems()*/;
    } else {
	this->items = 1;
    }

    this->control_size = ftp_ctlsize();

    /* We need the control_buf to be set as a legacy of the original, non-threaded
     * version of TrafGen.  In characterize_traffic(), if the control_buf exists,
     * then we haven't finished sending it yet.  If the control_buf is NULL, then
     * we infer that it's time to send the data.  The buffer itself is not used
     * because we use the single gigantic data source for all transfers */
    this->control_buf = (char *)1;

    /* Debugging */
    if(debug >= 2)
	printf("FTP stream started: %d - ctl, %d - #, %d - size\n", 
	       this->control_size, this->items, this->traffic_size);
    
    /* Make the connection if you can */
    sprintf(buf, "%d", this->port);

    if((this->descriptor = connectTCP(this->address, buf)) < 0) {
	fprintf(stderr, "Can't make ftp connection to %s on port %s.\n",
		this->address, buf);
	pthread_exit(NULL);
    }
    
    if(debug >= 2)
	printf("file descriptor - %d (7)\n", this->descriptor);

    return;
}



/* **************************************************************************
 * 
 * Function Name: characterize_telnet
 * 
 * Returns: Nothing
 *
 * Purpose: To characterize the TELNET connection and to provide the first
 *          set of packet specific characteristics.  To open the connection
 *          to the discard server.
 *
 * Called by: characterize_traffic() in trafgen.c
 * 
 * 
 * ***************************************************************************/
void characterize_telnet(
    struct traf_gen *this /* Item to be configured */
    )
{
    char buf[30];          /* Character buffer */
    struct timeval timer;  /* We need to set up the time for THIS packet -
			      first packet gets the time now. */

    gettimeofday(&timer, (struct timezone *)0);

    /* We're using items to be the seconds of the last packet that left.  
     * Control_size is the microseconds of when the last packet left */
    this->items = timer.tv_sec;
    this->control_size = timer.tv_usec;

    this->last.tv_sec = timer.tv_sec;
    this->last.tv_usec = timer.tv_usec;

    /* Set the stream as active */
    this->active = 1;

    /* Allow tcplib to set up attributes */
    this->inactive_timer = telnet_interarrival();
    this->traffic_size = telnet_pktsize();
    
    /* Debugging */
    if(debug >= 2)
	printf("Telnet stream started - %d - dur, %d - inter, %d - size\n",
	       this->active_timer, this->inactive_timer, this->traffic_size);
    
    /* Make the connection */
    sprintf(buf, "%d", this->port);
    
    if((this->descriptor = connectTCP(this->address, buf)) < 0) {
	fprintf(stderr, "Can't make telnet connection to %s on port %s\n",
		this->address, buf);
	pthread_exit(NULL);
    }
    
    if(debug >= 2)
	printf("file descriptor - %d (10)\n", this->descriptor);

    return;
}


/* **************************************************************************
 * 
 * Function Name: characterize_nntp
 * 
 * Returns: Nothing
 *
 * Purpose: To set the values of a connection to accurately model an
 *          NNTP connection.  Opens a connection to the discard server.
 *
 * Called by: characterize_traffic() in trafgen.c
 * 
 * ***************************************************************************/
void characterize_nntp(
    struct traf_gen *this  /* Item to be configured */
    )
{
    char buf[30];    /* Character buffer */

    /* Set the stream as active */
    this->active = 1;

    /* Allow tcplib to set attributes */
    if(this->traffic_size == -1) {
	this->traffic_size = nntp_itemsize();

	/* In the final model, we would use this.  The problem is that in
	 * addition to not quite knowing how to use this information, we
	 * don't know how to acquire the information. */
	this->items = 1 /*nntp_nitems()*/;
    } else {
	this->items = (this->traffic_size / default_mtu) + 1;
	this->traffic_size = default_mtu;
    }
    
    /* Debugging */
    if(debug >= 2)
	printf("NNTP stream started - %d - #, %d - size\n",
	       this->items, this->traffic_size);
    
    /* Make the connection */
    sprintf(buf, "%d", this->port);
    if((this->descriptor = connectTCP(this->address, buf)) < 0) {
	fprintf(stderr, "Can't make NNTP connection to %s on port %s\n",
		this->address, buf);
	pthread_exit(NULL);
    }
    
    if(debug >= 2)
	printf("file descriptor - %d (8)\n", this->descriptor);

    return;
}


/* **************************************************************************
 * 
 * Function Name: characterize_smtp
 * 
 * Returns: Nothing
 *
 * Purpose: Sets up the information needed to accurately model an SMTP
 *          connection.  Opens a connection to the discard server.
 *
 * Called by: characterize_traffic() in trafgen.c
 * 
 * ***************************************************************************/
void characterize_smtp(
    struct traf_gen *this /* Item to be configured like smtp */
    )
{
    char buf[30];    /* Character buffer */

    /* Set the stream as active */
    this->active = 1;
    
    /* Set the attributes for the stream */
    if(this->traffic_size == -1)
	this->traffic_size = smtp_itemsize();
    
    /* Do a little debugging */
    if(debug >= 2)
	printf("SMTP stream started - %d - size\n", this->traffic_size);
    
    /* Make a connection here or there or somewhere */
    sprintf(buf, "%d", this->port);

    if((this->descriptor = connectTCP(this->address, buf)) < 0) {
	fprintf(stderr, "Can't make SMTP connection to %s on port %s\n",
		this->address, buf);
	pthread_exit(NULL);
    }
    
    if(debug >=2)
	printf("file descriptor - %d (9)\n", this->descriptor);

    return;
}

/* **************************************************************************
 * 
 * Function Name: characterize_http
 * 
 * Returns: Nothing
 *
 * Purpose: Sets up an HTTP connection to accurately model a real HTTP 
 *          connection.  Opens a connection to the discard server.
 *
 * Called by: characterize_traffic() in trafgen.c
 * 
 * ***************************************************************************/
void characterize_http(
    struct traf_gen *this /* Item to be configured like smtp */
    )
{
    char buf[30];   /* Character buffer */

    /* Set the stream as active */
    this->active = 1;
    
    /* Set the attributes for the stream */
    if(this->traffic_size == -1)
	this->traffic_size = http_itemsize();
    
    /* Do a little debugging */
    if(debug >= 2)
	printf("HTTP stream started - %d - size\n", this->traffic_size);
    
    /* Make a connection here or there or somewhere */
    sprintf(buf, "%d", this->port);

    if((this->descriptor = connectTCP(this->address, buf)) < 0) {
	fprintf(stderr, "Can't make HTTP connection to %s on port %s\n",
		this->address, buf);
	pthread_exit(NULL);
    }
	
    if(debug >= 2)
	printf("file descriptor - %d (12)\n", this->descriptor);

    return;
}


/* **************************************************************************
 * 
 * Function Name: characterize_traffic
 * 
 * Returns: Nothing
 *
 * Purpose: Characterize_traffic coordinates the sending of data over
 *          the network.  Based on the kind of connection that is passed
 *          into the function, characterize_traffic will set parameters,
 *          open and close secondary connections, and schedule type-specific
 *          transfers.
 *
 * Called by: generate_traffic() in trafgen.c
 * 
 * ***************************************************************************/
void characterize_traffic(
    struct traf_gen *this /* The stream to be acted upon */
    )
{
    struct timeval timer;  /* Used to get the time now */
    int temp1, temp2;      /* Used to store time differences for telnet */
    struct timespec sleepy, wakey;  /* Time values used for sleeping */

    /* This was originally placed here to handle the situations we encountered
     * by having only the connection process threaded. */
    if(   this->active 
       && (this->descriptor == -1)
       && (this->type != TYPE_TCPLIB))
	return;

    switch(this->type) {
      case TYPE_TCPLIB:

	/* tcplib types are pretty simple.  If they're not active, activate them, and
	   set the start time.  Always go ahead and clear the number of slaves, since
	   back up in generate traffic, counting slaves comes after this. */
	if(!(this->active)) {
	    gettimeofday(&(this->start), (struct timezone *)0);
	    this->active = 1;

	    this->last.tv_sec = this->start.tv_sec;
	    this->last.tv_usec = this->start.tv_usec;

	    this->slave_delay = 0;
	} 

	this->active = 1;
	this->slave_delay = 0;

	gettimeofday(&timer, (struct timezone *)0);

	temp1 = (timer.tv_sec - this->last.tv_sec)*1000 +
	        (timer.tv_usec - this->last.tv_usec)/1000;

	break;
	
      case TYPE_TL_FTP:
      case TYPE_FTP:
	/* If we got here, then the stream needs to be activated.  So characterize it,
	   and by characterizing it, we'll activate it. */
	if(!(this->active)) {
	    gettimeofday(&(this->start), (struct timezone *)0);
	    characterize_ftp(this);
	    break;
	}

	/* If the item count is zero, we've sent all our items, so it's time
	   to set this stream as deactivated. */
	if(this->items == 0)
	    this->active = -1;
	else {

	    /* Control stuff goes first.  If we have an active control buffer, 
	       go ahead and send it.  After we send it, we'll nuke it, which
	       means that the next time we pass this way, we won't come here,
	       we'll go down to part 2. */
	    if(this->control_buf) {
		int ftp_bufferizer;

		ftp_bufferizer = telnet_pktsize();

		/* Send the data */
		write(this->descriptor, huge_buffer, ftp_bufferizer);

		this->control_size -= ftp_bufferizer;

		if(this->control_size < 0) {
		    this->control_buf = NULL;
		    this->control_size = 0;
		}

		/* Debugging */
		if(debug >= 2)
		    printf("Sent FTP control sequence.\n");

		/* Reset the timer for the next round */
		this->inactive_timer = telnet_interarrival();
		
		if(debug >= 3)
		    printf("ID %d FTP interarrival time - %d\n", this->id, this->inactive_timer);

		gettimeofday(&timer, (struct timezone *)0);

		this->last.tv_sec = timer.tv_sec;
		this->last.tv_usec = timer.tv_usec;
		
		sleepy.tv_sec = (time_t)(this->inactive_timer / 1000);
		sleepy.tv_nsec = (time_t)((this->inactive_timer % 1000) * 1000000);

		if((my_sleep(&sleepy, &wakey))) {
		    printf("my_sleep didn't return 0 - %ld.%09ld\n", wakey.tv_sec, wakey.tv_nsec);
		}
	    } else {
		/* Getting here means that we've sent out control sequence and
		   we still have items to send.  So what we do is we send one.
		   By sending one, we reduce the number we have left to send.
		   Spiffy how that works, eh? */
		this->items--;

		setup_ftp_data_connection(this);

		write(this->ftp_data_descriptor, huge_buffer, this->traffic_size);

		this->traffic_buf = NULL;

		this->traffic_size = ftp_itemsize();

		close(this->ftp_data_descriptor);

		if(!this->items)
		    this->active = -1;

		/* Debugging */
		if(debug >= 2)
		    printf("Sent FTP data.\n");
	    }
	}
	break;
	
      case TYPE_TL_TELNET:
      case TYPE_TELNET:
	/* Telnet is by far and away the most "interesting" of the bunch so far.
	   Basically, as I understand it from the man pages on tcplib, tcplib gives
	   us a total duration for the telnet connection, a interpacket time, and 
	   a response packet size.

	   So... what we have to do is keep track of the total duration of the 
	   connection, which this->start does, and we don't worry about here.
	   generate_traffic handles that part.

	   We have to worry about the interpacket delays, though.  So what we do is 
	   use some unused fields in the traf_gen struct to keep track of when we 
	   sent the last packet.  This means that every time we get here, we have
	   to check time of day in order to see if it's time to send the next
	   packet.  Ugly.

	   Additionally, for each telnet packet you send as a source, you receive
	   something back.  So... what I do is first I send a packet, then I switch
	   the active field to indicate that the next time through we're supposed
	   to receive a packet.  And if we just received one, we set things up to 
	   send on next time.  It's quite interesting.
	*/

	/* At any rate... when we're here, we check to see if the item is
	   active, and if not we characterize it. */
	if(!(this->active)) {
	    if(debug >= 3)
		printf("Characterizing telnet\n");

	    gettimeofday(&(this->start), (struct timezone *)0);
	    characterize_telnet(this);
	    break;
	}

	if(debug >= 3)
	    printf("Telnet stage 1\n");

	/* The active one means that we're supposed to send a packet. */
	if(this->active == 1) {

	    if(debug >= 3)
		printf("Telnet stage 2\n");

	    gettimeofday(&timer, (struct timezone *)0);

	    temp2 = (timer.tv_sec - this->last.tv_sec)*1000 +
		    (timer.tv_usec - this->last.tv_usec)/1000;

	    if(debug >= 3)
		printf("temp2 - %d  -- this->inactive_timer - %d\n", temp2, this->inactive_timer);

	    if(temp2 >= this->inactive_timer) {
		static struct timeval before, after;
		static int first = 0;

		/* Set the activity level to be receive */
/*		this->active = 2;*/

		if(debug >= 3)
		    printf("Telnet stage 3\n");

		if(!first) {
		    first = 1;
		    gettimeofday(&before, (struct timezone *)NULL);
		    gettimeofday(&after, (struct timezone *)NULL);
		}
		    
		/* Send the data */
		this->traffic_size = telnet_pktsize();

		if(debug >= 3)
		    printf("Telnet packetsize - %d\n", this->traffic_size);

		gettimeofday(&before, (struct timezone *)NULL);

		if(debug >= 3)
		    printf("ID %d Time difference - %ld\n", this->id, 
			   (((before.tv_sec - after.tv_sec) * 1000) + 
			    ((before.tv_usec - after.tv_usec) / 1000)));

		write(this->descriptor, huge_buffer, telnet_pktsize());

		gettimeofday(&after, (struct timezone *)NULL);

		if(debug >= 3)
		    printf("ID: %d Packet sent at: %ld.%6ld\n", this->id, after.tv_sec, after.tv_usec);

		if(debug >= 3)
		    printf("ID: %d Time to write data - %ld ms\n", this->id,
			   (((after.tv_sec - before.tv_sec) * 1000) -
			    ((after.tv_usec - before.tv_usec) / 1000)));

		/* Reset the timer for the next round */
		this->inactive_timer = telnet_interarrival();
		
		if(debug >= 3)
		    printf("ID %d Telnet interarrival time - %d\n", this->id, this->inactive_timer);

		/*free(this->traffic_buf);*/

		this->last.tv_sec = timer.tv_sec;
		this->last.tv_usec = timer.tv_usec;
		

		/* Do a little debugging and a drink a litta wata */
		if(debug >= 2)
		    printf("Sent outgoing Telnet packet.\n");

		sleepy.tv_sec = (time_t)(this->inactive_timer / 1000);
		sleepy.tv_nsec = (time_t)((this->inactive_timer % 1000) * 1000000);

		if((my_sleep(&sleepy, &wakey))) {
		    printf("my_sleep didn't return 0 - %ld.%09ld\n", wakey.tv_sec, wakey.tv_nsec);
		}

/*		usleep(this->inactive_timer * 1000);*/

	    } else {
		/* Inactive stage */
		;
	    }

/*	} else {*/
	    /* This means we're in the receive state.  Receiving is
	       much more straight forward than sending... so...
	       All we have to do set the stream to send, and send the
	       data that we're receiving.  We play both sides in this
	       conversation... it's like talking to yourself over the 
	       phone. */
/*	    this->active = 1;*/

	    /* Send the data that we're receiving to the person we're
	       receiving it from.  Doncha love simulations? */
/*	    write(this->descriptor, huge_buffer, this->traffic_size);*/

	    /* Debug THIS! */
/*	    if(debug >=4)
		printf("Wrote incoming Telnet packet.\n");*/
	}
	break;
	
      case TYPE_TL_NNTP:
      case TYPE_NNTP:
	/* NNTP and SMTP are really simple.  If you've figured out
	   the FTP and the Telnet you won't have any problem here. */
	if(!(this->active)) {
	    gettimeofday(&(this->start), (struct timezone *)0);
	    characterize_nntp(this);
	    break;
	}

	if(this->items == 0)
	    this->active = -1;
	else {
	    write(this->descriptor, huge_buffer, this->traffic_size);
	    this->items--;

	    this->traffic_buf = NULL;

	    this->traffic_size = nntp_itemsize();

	    if(!this->items)
		this->active = -1;

	    if(debug >= 2)
		printf("Sent NNTP data.\n");
	}
	break;
	
      case TYPE_TL_SMTP:
      case TYPE_SMTP:
	if(!(this->active)) {
	    gettimeofday(&(this->start), (struct timezone *)0);
	    characterize_smtp(this);
	   
	} else {
	    write(this->descriptor, huge_buffer, this->traffic_size);

	    this->traffic_buf = NULL;

	    this->active = -1;

	    if(debug >= 2)
		printf("Sent SMTP data.\n");
	}

	break;
	
      case TYPE_TL_HTTP:
      case TYPE_HTTP:
	if(!(this->active)) {
	    gettimeofday(&(this->start), (struct timezone *)0);
	    characterize_http(this);
	   
	} else {
	    write(this->descriptor, huge_buffer, this->traffic_size);

	    this->traffic_buf = NULL;

	    this->active = -1;

	    if(debug >= 2)
		printf("Sent HTTP data.\n");
	}

	break;
	
      default:
	printf("No information on characterizing non-standard streams.\n");
	break;
    }
    
}

/* We're going to sort the list of the schedule items we received from
   the configuration file so that the one with the lowest delay (the
   one that will trigger first) is on top. We dont' really need to do
   this, but I did anyways.  It doesn't take that long, and it'll get
   us started about .0004 seconds faster. */
int sort_schedule_list(
    )
{
    struct traf_gen *runner = NULL,     /* Finds the lowest remaining delay */
	            *low = NULL,        /* Holds the lowest remaining dealy */
                    *outer = NULL,      /* The outer loop */
                    *follower = NULL,   /* Finds the item just before outer */
                    *lowfollow = NULL;  /* Finds the item just before low */

    outer = schedule;

    /* We just redo the entire schedule.  Was easier than
       trying to shuffle stuff around inside the list */
    schedule = NULL;
    
    /* We quit after we've moved everything from the outer list to the
       schedule list. */
    while(outer) {
	low = outer;

	/* This stuff's all pretty straight forward so I won't spend
	   much time on it.  Suffice it to say, we find the lowest 
	   delay still in the outer list, and move than item over to
	   the schedule list, while removing it from the outer list */
	for(runner = outer; runner != NULL; runner = runner->next) {
	    if(runner->delay < low->delay)
		low = runner;
	}

	if(low == outer) {
	    outer = outer->next;
	} else {
	    for(follower = outer; follower->next != low; follower = follower->next);

	    follower->next = low->next;
	}

	if(!schedule) {
	    schedule = low;
	    lowfollow = schedule;
	    schedule->next = NULL;
	} else {
	    lowfollow->next = low;
	    lowfollow = low;
	    lowfollow->next = NULL;
	}
    }

    return 1;
}


/* set_schedule is called from yacc.  I was having problems getting schedule
   to be set in yacc, so I made this little deal which sets it for me.
   This function is called at yacc's top level, the most general rule, after
   all the parsing and filling out of the data structures has been done */
void set_schedule(
    struct traf_gen *list  /* The head of the yacc list */
    )
{
    list->next = schedule;
    schedule = list;
}


/* clear_traf just initializes a traf_gen struct.  During initial testing
   I was getting some wierd values.  I figured this wasn't too hard and it
   would save crashes, adn therefore was a good thing */
void clear_traf(
    struct traf_gen *this
    )
{
    this->type = -1;
    this->address = NULL;
    this->delay = 0;
    this->control_buf = NULL;
    this->traffic_buf = NULL;
    this->control_size = 0;
    this->traffic_size = -1;
    this->items = 0;
    this->descriptor = -1;
    this->active_timer = -1;
    this->inactive_timer = 0;
    this->port = 0;
    this->slave_delay = 0;
    this->active = 0;
    this->last.tv_sec = 0;
    this->last.tv_usec = 0;
    this->start.tv_sec = 0;
    this->start.tv_usec = 0;
    this->master = NULL;
    this->next = NULL;
}


/* When I was looking at Jason's code (the guy who was doing a little 
   of this work before me) I noticed that he was allocating new stream
   buffers each time through, and never freeing them.  This reminded me
   that I needed to free mine.  Additionally, I was getting some errors
   about not being able to get the address for the discard port on a
   local machine... I eventually came to the realization that I was 
   soaking up all the damn file descriptors.  So in addition to freeing
   up memory, I also close connections here. */
void free_traffic(
    struct traf_gen *this  /* Item to get freed and closed */
    )
{

    if(debug >= 2)
	printf("Freeing item\n");

    if(this->address)
	free(this->address);

    free(this);
}


/* Just a cheesy little function used to debug yacc */
void print_schedule(
    struct traf_gen *schedule  /* Head of the list to get printed. */
    )
{
    struct traf_gen *runner;  /* Looping pointer */
    int i = 0;                /* Counter */

    for(runner = schedule; runner; runner=runner->next) {
	printf("Item number %d.\n", ++i);
	printf("Traffic type: %d\n", runner->type);
	printf("Host: %s\n", (runner->address));
	printf("Delay: %d\n", runner->delay);
	printf("Streams: %d\n", runner->items);
	printf("Port: %d\n", runner->port);
	printf("Duration: %d\n", runner->active_timer);
    }
}

/* We're going to run under the assumption that we'll be using a file
   which contains all the information we'll need to generate the
   network traffic requested by the user.  So we're assuming that the
   user has created this configuration file, but will need to specify
   the name of the file at run time.
*/
int parse_configuration(
    char *conf_file  /* Name of the config file */
    )
{
    FILE *fp;                   /* Configuration file pointer */

    if(debug >= 5)
	printf("Conf file = %s\n", conf_file);

    /* First job, open the file, if it exists. */
    if(!(fp = fopen(conf_file, "r"))) {
	fprintf(stderr, "Error in trafgen execution - unable to open configuration file.\n");
	exit(1);
    }

    /* We're going to use lex and yacc to parse the input file, so now
       we need to point the yyin file pointer at our file, fp */
    yyin = fp;

    /* Now we let lex and yacc take over */
    while(!feof(yyin)) {

	/* Let yacc parse the configuration file.  During the parseing, the
	   schedule pointer will get filled with the schedule of events, their
	   attributes, and start times. */
	if(yyparse()) {
	    fprintf(stderr, "Error during configuration file parsing.\n");
	    exit(1);
	}
    }

    /* Now we want to sort the schedule by order of increasing delays.
       This way, we'll have the item that needs to happen first at the
       top of the list.  */
    sort_schedule_list();

    if(debug >= 3)
	print_schedule(schedule);

    return 1;
}
    
	
int yyerror(char *s)
{
  printf("%s\r\n", s);
  return 0;
}

int yywrap()
{
  return 1;
}


#include <sys/resource.h>


static void
SetMaxFiles(int max)
{
    struct rlimit rl;

    /* see what they're set at now */
    if (getrlimit(RLIMIT_NOFILE,&rl) != 0) {
	perror("getrlimit");
    }

    if (debug>1)
	printf("Current limits on open files:  cur:%ld   max:%ld\n",
	       rl.rlim_cur, rl.rlim_max);


    /* try to change them... */
    rl.rlim_cur = max;
    if (setrlimit(RLIMIT_NOFILE,&rl) != 0) {
	/*SysWarn*/perror("setrlimit");
    }

    /* see what they're set to NOW */
    if (getrlimit(RLIMIT_NOFILE,&rl) != 0) {
    }

    if (debug>1)
	printf("NEW limits on open files:  cur:%ld   max:%ld\n",
	       rl.rlim_cur, rl.rlim_max);
    
}


void quit(
    int signum,
    siginfo_t *psiginfo,
    void *junk)  /* context, ignored */
{
    char signame[100];

    sig2str(signum,signame);
    fprintf(stderr,"Caught signal %s (%d)\n", signame, signum);

    if (psiginfo) {
	/* see who sent it */
	fprintf(stderr,"\t signo:%d  errno:%d  code:%d\n",
		psiginfo->si_signo,
		psiginfo->si_errno,
		psiginfo->si_code);
	if (psiginfo->si_code <= 0) {
	    /* from a user process */
	    fprintf(stderr,"\t from user uid:%d, process id:%d\n",
		(int) psiginfo->si_uid,
		(int) psiginfo->si_pid);
	} else {
	    /* from the OS */
	    fprintf(stderr,"\t from the OS\n");
	}
    }

    Signal(SIGALRM);
}

void Signal(
    int signum)
{
    static struct sigaction action;

    if(debug >= 6)
	printf("here we are in signal.\n");

    /* zero out the mask and etc...*/
    memset(&action, '\00', sizeof(action));

    action.sa_handler = NULL;	/* we use sig_action instead */
    action.sa_sigaction = quit;  
    action.sa_flags = SA_SIGINFO;

    if (sigaction(signum,&action,(struct sigaction *)NULL) != 0) {
	perror("sigaction");
	exit(-1);
    }

    if(debug >= 6)
	printf("here we are leaving signal\n");
}

int my_sleep(struct timespec *sleep, struct timespec *blah)
{
    struct timeval begin, now, end;
    struct timespec newsleep;
    
    gettimeofday(&now, (struct timezone *)NULL);
    begin.tv_sec = now.tv_sec;
    begin.tv_usec = now.tv_usec;
    end.tv_sec = now.tv_sec + sleep->tv_sec;
    end.tv_usec = now.tv_usec + sleep->tv_nsec / 1000;

    newsleep.tv_nsec = sleep->tv_nsec;
    newsleep.tv_sec = sleep->tv_sec;

/*     if(newsleep.tv_nsec < 0) { */
/* 	newsleep.tv_nsec += 1000000000; */
/* 	newsleep.tv_sec -= 1; */
/*     } */
/*     if(newsleep.tv_sec >= 0) */
    nanosleep(&newsleep, blah);

    gettimeofday(&now, (struct timezone *)NULL);

    while((((end.tv_sec - now.tv_sec) * 1000000) + (end.tv_usec - now.tv_usec)) > 0) {
	sched_yield();
	gettimeofday(&now, (struct timezone *)NULL);
    }

    if(debug >= 5)
	printf("Supposed to sleep for %ld ms, slept for %ld ms.\n",
	       ((sleep->tv_sec * 1000) + (sleep->tv_nsec / 1000000)),
	       (((end.tv_sec - begin.tv_sec) * 1000) + 
		((end.tv_usec - begin.tv_usec) / 1000)));
    return 0;
}
